// This is a generated file. Not intended for manual editing.
package org.vlang.lang;

import com.intellij.psi.tree.IElementType;
import com.intellij.psi.PsiElement;
import com.intellij.lang.ASTNode;
import org.vlang.lang.psi.VlangCompositeElementType;
import org.vlang.lang.stubs.VlangElementTypeFactory;
import org.vlang.lang.psi.VlangTokenType;
import org.vlang.lang.psi.impl.*;

public interface VlangTypes {

  IElementType ADD_EXPR = new VlangCompositeElementType("ADD_EXPR");
  IElementType AND_EXPR = new VlangCompositeElementType("AND_EXPR");
  IElementType ANONYMOUS_FIELD_DEFINITION = new VlangCompositeElementType("ANONYMOUS_FIELD_DEFINITION");
  IElementType ANONYMOUS_INTERFACE_DEFINITION = new VlangCompositeElementType("ANONYMOUS_INTERFACE_DEFINITION");
  IElementType ARGUMENT_LIST = new VlangCompositeElementType("ARGUMENT_LIST");
  IElementType ARRAY_CREATION = new VlangCompositeElementType("ARRAY_CREATION");
  IElementType ARRAY_CREATION_LIST = new VlangCompositeElementType("ARRAY_CREATION_LIST");
  IElementType ARRAY_OR_SLICE_TYPE = new VlangCompositeElementType("ARRAY_OR_SLICE_TYPE");
  IElementType ASM_BLOCK = new VlangCompositeElementType("ASM_BLOCK");
  IElementType ASM_BLOCK_STATEMENT = new VlangCompositeElementType("ASM_BLOCK_STATEMENT");
  IElementType ASSERT_STATEMENT = new VlangCompositeElementType("ASSERT_STATEMENT");
  IElementType ASSIGNMENT_STATEMENT = new VlangCompositeElementType("ASSIGNMENT_STATEMENT");
  IElementType ASSIGN_OP = new VlangCompositeElementType("ASSIGN_OP");
  IElementType AS_EXPRESSION = new VlangCompositeElementType("AS_EXPRESSION");
  IElementType ATTRIBUTE = new VlangCompositeElementType("ATTRIBUTE");
  IElementType ATTRIBUTES = new VlangCompositeElementType("ATTRIBUTES");
  IElementType ATTRIBUTE_EXPRESSION = new VlangCompositeElementType("ATTRIBUTE_EXPRESSION");
  IElementType BLOCK = new VlangCompositeElementType("BLOCK");
  IElementType BREAK_STATEMENT = new VlangCompositeElementType("BREAK_STATEMENT");
  IElementType CALL_EXPR = new VlangCompositeElementType("CALL_EXPR");
  IElementType CAPTURE = new VlangCompositeElementType("CAPTURE");
  IElementType CAPTURE_LIST = new VlangCompositeElementType("CAPTURE_LIST");
  IElementType CHANNEL_TYPE = new VlangCompositeElementType("CHANNEL_TYPE");
  IElementType COMPILE_ELSE_STATEMENT = new VlangCompositeElementType("COMPILE_ELSE_STATEMENT");
  IElementType COMPILE_TIME_FOR_STATEMENT = new VlangCompositeElementType("COMPILE_TIME_FOR_STATEMENT");
  IElementType COMPILE_TIME_IF_EXPRESSION = new VlangCompositeElementType("COMPILE_TIME_IF_EXPRESSION");
  IElementType COMPILE_TIME_IF_STATEMENT = new VlangCompositeElementType("COMPILE_TIME_IF_STATEMENT");
  IElementType CONDITIONAL_EXPR = new VlangCompositeElementType("CONDITIONAL_EXPR");
  IElementType CONSTEXPR_IDENTIFIER_EXPRESSION = new VlangCompositeElementType("CONSTEXPR_IDENTIFIER_EXPRESSION");
  IElementType CONST_DECLARATION = new VlangCompositeElementType("CONST_DECLARATION");
  IElementType CONST_DEFINITION = new VlangCompositeElementType("CONST_DEFINITION");
  IElementType CONST_SPEC = new VlangCompositeElementType("CONST_SPEC");
  IElementType CONTINUE_STATEMENT = new VlangCompositeElementType("CONTINUE_STATEMENT");
  IElementType C_FLAG_STATEMENT = new VlangCompositeElementType("C_FLAG_STATEMENT");
  IElementType C_INCLUDE_STATEMENT = new VlangCompositeElementType("C_INCLUDE_STATEMENT");
  IElementType DEFAULT_FIELD_VALUE = new VlangCompositeElementType("DEFAULT_FIELD_VALUE");
  IElementType DEFER_STATEMENT = new VlangCompositeElementType("DEFER_STATEMENT");
  IElementType DOT_EXPRESSION = new VlangCompositeElementType("DOT_EXPRESSION");
  IElementType ELSE_STATEMENT = new VlangCompositeElementType("ELSE_STATEMENT");
  IElementType ENUM_DECLARATION = VlangElementTypeFactory.stubFactory("ENUM_DECLARATION");
  IElementType ENUM_FETCH = new VlangCompositeElementType("ENUM_FETCH");
  IElementType ENUM_FIELDS = new VlangCompositeElementType("ENUM_FIELDS");
  IElementType ENUM_FIELD_DECLARATION = new VlangCompositeElementType("ENUM_FIELD_DECLARATION");
  IElementType ERROR_PROPAGATION_EXPRESSION = new VlangCompositeElementType("ERROR_PROPAGATION_EXPRESSION");
  IElementType EXPRESSION = new VlangCompositeElementType("EXPRESSION");
  IElementType FIELD_DECLARATION = new VlangCompositeElementType("FIELD_DECLARATION");
  IElementType FIELD_INITIALIZATION = new VlangCompositeElementType("FIELD_INITIALIZATION");
  IElementType FIELD_INITIALIZATION_KEY = new VlangCompositeElementType("FIELD_INITIALIZATION_KEY");
  IElementType FIELD_INITIALIZATION_KEY_VALUE_LIST = new VlangCompositeElementType("FIELD_INITIALIZATION_KEY_VALUE_LIST");
  IElementType FIELD_INITIALIZATION_VALUE_LIST = new VlangCompositeElementType("FIELD_INITIALIZATION_VALUE_LIST");
  IElementType FIELD_LOOKUP = new VlangCompositeElementType("FIELD_LOOKUP");
  IElementType FIELD_NAME = new VlangCompositeElementType("FIELD_NAME");
  IElementType FORCE_NO_ERROR_PROPAGATION_EXPRESSION = new VlangCompositeElementType("FORCE_NO_ERROR_PROPAGATION_EXPRESSION");
  IElementType FOR_CLAUSE = new VlangCompositeElementType("FOR_CLAUSE");
  IElementType FOR_STATEMENT = new VlangCompositeElementType("FOR_STATEMENT");
  IElementType FUNCTION_DECLARATION = VlangElementTypeFactory.stubFactory("FUNCTION_DECLARATION");
  IElementType FUNCTION_LIT = new VlangCompositeElementType("FUNCTION_LIT");
  IElementType FUNCTION_TYPE = new VlangCompositeElementType("FUNCTION_TYPE");
  IElementType GENERIC_DECLARATION = new VlangCompositeElementType("GENERIC_DECLARATION");
  IElementType GENERIC_DECLARATION_LIST = new VlangCompositeElementType("GENERIC_DECLARATION_LIST");
  IElementType GENERIC_NAME = new VlangCompositeElementType("GENERIC_NAME");
  IElementType GLOBAL_VARIABLE_DECLARATION = new VlangCompositeElementType("GLOBAL_VARIABLE_DECLARATION");
  IElementType GOTO_STATEMENT = new VlangCompositeElementType("GOTO_STATEMENT");
  IElementType GO_EXPRESSION = new VlangCompositeElementType("GO_EXPRESSION");
  IElementType GO_STATEMENT = new VlangCompositeElementType("GO_STATEMENT");
  IElementType IF_ATTRIBUTE = new VlangCompositeElementType("IF_ATTRIBUTE");
  IElementType IF_EXPRESSION = new VlangCompositeElementType("IF_EXPRESSION");
  IElementType IF_STATEMENT = new VlangCompositeElementType("IF_STATEMENT");
  IElementType IMPORT_ALIAS = new VlangCompositeElementType("IMPORT_ALIAS");
  IElementType IMPORT_DECLARATION = new VlangCompositeElementType("IMPORT_DECLARATION");
  IElementType IMPORT_LIST = new VlangCompositeElementType("IMPORT_LIST");
  IElementType IMPORT_SPEC = new VlangCompositeElementType("IMPORT_SPEC");
  IElementType INC_DEC_EXPRESSION = new VlangCompositeElementType("INC_DEC_EXPRESSION");
  IElementType INDEX_OR_SLICE_EXPR = new VlangCompositeElementType("INDEX_OR_SLICE_EXPR");
  IElementType INTERFACE_DECLARATION = new VlangCompositeElementType("INTERFACE_DECLARATION");
  IElementType INTERFACE_FIELD_DECLARATION = new VlangCompositeElementType("INTERFACE_FIELD_DECLARATION");
  IElementType INTERFACE_METHOD_DECLARATION = new VlangCompositeElementType("INTERFACE_METHOD_DECLARATION");
  IElementType INTERFACE_TYPE = new VlangCompositeElementType("INTERFACE_TYPE");
  IElementType IN_EXPRESSION = new VlangCompositeElementType("IN_EXPRESSION");
  IElementType IS_EXPRESSION = new VlangCompositeElementType("IS_EXPRESSION");
  IElementType KEY_VALUE = new VlangCompositeElementType("KEY_VALUE");
  IElementType KEY_VALUES = new VlangCompositeElementType("KEY_VALUES");
  IElementType LABEL = new VlangCompositeElementType("LABEL");
  IElementType LABELED_STATEMENT = new VlangCompositeElementType("LABELED_STATEMENT");
  IElementType LABEL_REF = new VlangCompositeElementType("LABEL_REF");
  IElementType LANGUAGE_INJECTION_STATEMENT = new VlangCompositeElementType("LANGUAGE_INJECTION_STATEMENT");
  IElementType LEFT_HAND_EXPR_LIST = new VlangCompositeElementType("LEFT_HAND_EXPR_LIST");
  IElementType LITERAL = new VlangCompositeElementType("LITERAL");
  IElementType LOCK_EXPRESSION = new VlangCompositeElementType("LOCK_EXPRESSION");
  IElementType LOCK_STATEMENT = new VlangCompositeElementType("LOCK_STATEMENT");
  IElementType MAP_INIT_EXPR = new VlangCompositeElementType("MAP_INIT_EXPR");
  IElementType MAP_TYPE = new VlangCompositeElementType("MAP_TYPE");
  IElementType MATCH_ARM = new VlangCompositeElementType("MATCH_ARM");
  IElementType MATCH_ARMS = new VlangCompositeElementType("MATCH_ARMS");
  IElementType MATCH_ELSE_ARM_CLAUSE = new VlangCompositeElementType("MATCH_ELSE_ARM_CLAUSE");
  IElementType MATCH_EXPRESSION = new VlangCompositeElementType("MATCH_EXPRESSION");
  IElementType MEMBER_MODIFIER = new VlangCompositeElementType("MEMBER_MODIFIER");
  IElementType MEMBER_MODIFIERS = new VlangCompositeElementType("MEMBER_MODIFIERS");
  IElementType METHOD_CALL = new VlangCompositeElementType("METHOD_CALL");
  IElementType METHOD_DECLARATION = VlangElementTypeFactory.stubFactory("METHOD_DECLARATION");
  IElementType METHOD_NAME = new VlangCompositeElementType("METHOD_NAME");
  IElementType MODULE_CLAUSE = VlangElementTypeFactory.stubFactory("MODULE_CLAUSE");
  IElementType MUL_EXPR = new VlangCompositeElementType("MUL_EXPR");
  IElementType MUT_EXPRESSION = new VlangCompositeElementType("MUT_EXPRESSION");
  IElementType NOT_IN_EXPRESSION = new VlangCompositeElementType("NOT_IN_EXPRESSION");
  IElementType NOT_IS_EXPRESSION = new VlangCompositeElementType("NOT_IS_EXPRESSION");
  IElementType NOT_NULLABLE_TYPE = new VlangCompositeElementType("NOT_NULLABLE_TYPE");
  IElementType NULLABLE_TYPE = new VlangCompositeElementType("NULLABLE_TYPE");
  IElementType OR_BLOCK_EXPR = new VlangCompositeElementType("OR_BLOCK_EXPR");
  IElementType OR_EXPR = new VlangCompositeElementType("OR_EXPR");
  IElementType PARAMETERS = new VlangCompositeElementType("PARAMETERS");
  IElementType PARAMETER_DECLARATION = new VlangCompositeElementType("PARAMETER_DECLARATION");
  IElementType PARAM_DEFINITION = new VlangCompositeElementType("PARAM_DEFINITION");
  IElementType PARENTHESES_EXPR = new VlangCompositeElementType("PARENTHESES_EXPR");
  IElementType PLAIN_ATTRIBUTE = new VlangCompositeElementType("PLAIN_ATTRIBUTE");
  IElementType POINTER_TYPE = new VlangCompositeElementType("POINTER_TYPE");
  IElementType RANGE_CLAUSE = new VlangCompositeElementType("RANGE_CLAUSE");
  IElementType RANGE_EXPR = new VlangCompositeElementType("RANGE_EXPR");
  IElementType RECEIVER = new VlangCompositeElementType("RECEIVER");
  IElementType REFERENCE_EXPRESSION = new VlangCompositeElementType("REFERENCE_EXPRESSION");
  IElementType RESULT = new VlangCompositeElementType("RESULT");
  IElementType RETURN_STATEMENT = new VlangCompositeElementType("RETURN_STATEMENT");
  IElementType SELECTIVE_IMPORT_LIST = new VlangCompositeElementType("SELECTIVE_IMPORT_LIST");
  IElementType SEND_EXPR = new VlangCompositeElementType("SEND_EXPR");
  IElementType SEND_STATEMENT = new VlangCompositeElementType("SEND_STATEMENT");
  IElementType SHARED_EXPRESSION = new VlangCompositeElementType("SHARED_EXPRESSION");
  IElementType SIGNATURE = new VlangCompositeElementType("SIGNATURE");
  IElementType SIMPLE_STATEMENT = new VlangCompositeElementType("SIMPLE_STATEMENT");
  IElementType SQL_BLOCK = new VlangCompositeElementType("SQL_BLOCK");
  IElementType SQL_EXPRESSION = new VlangCompositeElementType("SQL_EXPRESSION");
  IElementType SQL_STATEMENT = new VlangCompositeElementType("SQL_STATEMENT");
  IElementType STATEMENT = new VlangCompositeElementType("STATEMENT");
  IElementType STRING_LITERAL = new VlangCompositeElementType("STRING_LITERAL");
  IElementType STRUCT_DECLARATION = VlangElementTypeFactory.stubFactory("STRUCT_DECLARATION");
  IElementType STRUCT_TYPE = new VlangCompositeElementType("STRUCT_TYPE");
  IElementType SYMBOL_VISIBILITY = new VlangCompositeElementType("SYMBOL_VISIBILITY");
  IElementType TAG = new VlangCompositeElementType("TAG");
  IElementType TYPE_ALIAS_DECLARATION = VlangElementTypeFactory.stubFactory("TYPE_ALIAS_DECLARATION");
  IElementType TYPE_DECL = new VlangCompositeElementType("TYPE_DECL");
  IElementType TYPE_INIT_EXPR = new VlangCompositeElementType("TYPE_INIT_EXPR");
  IElementType TYPE_LIST_NO_PIN = new VlangCompositeElementType("TYPE_LIST_NO_PIN");
  IElementType TYPE_REFERENCE_EXPRESSION = new VlangCompositeElementType("TYPE_REFERENCE_EXPRESSION");
  IElementType TYPE_UNION_LIST = new VlangCompositeElementType("TYPE_UNION_LIST");
  IElementType UNARY_EXPR = new VlangCompositeElementType("UNARY_EXPR");
  IElementType UNION_DECLARATION = VlangElementTypeFactory.stubFactory("UNION_DECLARATION");
  IElementType UNPACKING_EXPRESSION = new VlangCompositeElementType("UNPACKING_EXPRESSION");
  IElementType UNSAFE_EXPRESSION = new VlangCompositeElementType("UNSAFE_EXPRESSION");
  IElementType UNSAFE_STATEMENT = new VlangCompositeElementType("UNSAFE_STATEMENT");
  IElementType VAR_DECLARATION = new VlangCompositeElementType("VAR_DECLARATION");
  IElementType VAR_DEFINITION = new VlangCompositeElementType("VAR_DEFINITION");
  IElementType VAR_MODIFIERS = new VlangCompositeElementType("VAR_MODIFIERS");

  IElementType AS = new VlangTokenType("as");
  IElementType ASM = new VlangTokenType("asm");
  IElementType ASM_LINE = new VlangTokenType("ASM_LINE");
  IElementType ASSERT = new VlangTokenType("assert");
  IElementType ASSIGN = new VlangTokenType("=");
  IElementType AT = new VlangTokenType("@");
  IElementType BACKTICK = new VlangTokenType("`");
  IElementType BIN = new VlangTokenType("bin");
  IElementType BIT_AND = new VlangTokenType("&");
  IElementType BIT_AND_ASSIGN = new VlangTokenType("&=");
  IElementType BIT_CLEAR = new VlangTokenType("&^");
  IElementType BIT_CLEAR_ASSIGN = new VlangTokenType("&^=");
  IElementType BIT_OR = new VlangTokenType("|");
  IElementType BIT_OR_ASSIGN = new VlangTokenType("|=");
  IElementType BIT_XOR = new VlangTokenType("^");
  IElementType BIT_XOR_ASSIGN = new VlangTokenType("^=");
  IElementType BREAK = new VlangTokenType("break");
  IElementType BUILTIN_GLOBAL = new VlangTokenType("BUILTIN_GLOBAL");
  IElementType CASE = new VlangTokenType("case");
  IElementType CHAN = new VlangTokenType("chan");
  IElementType CHAR = new VlangTokenType("char");
  IElementType COLON = new VlangTokenType(":");
  IElementType COMMA = new VlangTokenType(",");
  IElementType COND_AND = new VlangTokenType("&&");
  IElementType COND_OR = new VlangTokenType("||");
  IElementType CONST = new VlangTokenType("const");
  IElementType CONTINUE = new VlangTokenType("continue");
  IElementType C_FLAG = new VlangTokenType("C_FLAG");
  IElementType C_FLAG_VALUE = new VlangTokenType("C_FLAG_VALUE");
  IElementType C_INCLUDE = new VlangTokenType("C_INCLUDE");
  IElementType DECIMALI = new VlangTokenType("decimali");
  IElementType DEFAULT = new VlangTokenType("default");
  IElementType DEFER = new VlangTokenType("defer");
  IElementType DOT = new VlangTokenType(".");
  IElementType DOUBLE_QUOTE = new VlangTokenType("\"");
  IElementType ELSE = new VlangTokenType("else");
  IElementType ELSE_COMPILE_TIME = new VlangTokenType("ELSE_COMPILE_TIME");
  IElementType ENUM = new VlangTokenType("enum");
  IElementType EQ = new VlangTokenType("==");
  IElementType FALLTHROUGH = new VlangTokenType("fallthrough");
  IElementType FALSE = new VlangTokenType("false");
  IElementType FLOAT = new VlangTokenType("float");
  IElementType FLOATI = new VlangTokenType("floati");
  IElementType FN = new VlangTokenType("fn");
  IElementType FOR = new VlangTokenType("for");
  IElementType FOR_COMPILE_TIME = new VlangTokenType("FOR_COMPILE_TIME");
  IElementType GO = new VlangTokenType("go");
  IElementType GOTO = new VlangTokenType("goto");
  IElementType GREATER = new VlangTokenType(">");
  IElementType GREATER_OR_EQUAL = new VlangTokenType(">=");
  IElementType HASH_LBRACK = new VlangTokenType("#[");
  IElementType HEX = new VlangTokenType("hex");
  IElementType IDENTIFIER = new VlangTokenType("identifier");
  IElementType IF = new VlangTokenType("if");
  IElementType IF_COMPILE_TIME = new VlangTokenType("IF_COMPILE_TIME");
  IElementType IMPORT = new VlangTokenType("import");
  IElementType IN = new VlangTokenType("in");
  IElementType INT = new VlangTokenType("int");
  IElementType INTERFACE = new VlangTokenType("interface");
  IElementType IS = new VlangTokenType("is");
  IElementType LANGUAGE_INJECTION = new VlangTokenType("LANGUAGE_INJECTION");
  IElementType LBRACE = new VlangTokenType("{");
  IElementType LBRACK = new VlangTokenType("[");
  IElementType LESS = new VlangTokenType("<");
  IElementType LESS_OR_EQUAL = new VlangTokenType("<=");
  IElementType LOCK = new VlangTokenType("lock");
  IElementType LPAREN = new VlangTokenType("(");
  IElementType MATCH = new VlangTokenType("match");
  IElementType MINUS = new VlangTokenType("-");
  IElementType MINUS_ASSIGN = new VlangTokenType("-=");
  IElementType MINUS_MINUS = new VlangTokenType("--");
  IElementType MODULE = new VlangTokenType("module");
  IElementType MUL = new VlangTokenType("*");
  IElementType MUL_ASSIGN = new VlangTokenType("*=");
  IElementType MUT = new VlangTokenType("mut");
  IElementType NOT = new VlangTokenType("!");
  IElementType NOT_EQ = new VlangTokenType("!=");
  IElementType NOT_IN = new VlangTokenType("NOT_IN");
  IElementType NOT_IS = new VlangTokenType("NOT_IS");
  IElementType OCT = new VlangTokenType("oct");
  IElementType OR = new VlangTokenType("or");
  IElementType PLUS = new VlangTokenType("+");
  IElementType PLUS_ASSIGN = new VlangTokenType("+=");
  IElementType PLUS_PLUS = new VlangTokenType("++");
  IElementType PUB = new VlangTokenType("pub");
  IElementType QUESTION = new VlangTokenType("?");
  IElementType QUOTIENT = new VlangTokenType("/");
  IElementType QUOTIENT_ASSIGN = new VlangTokenType("/=");
  IElementType RANGE = new VlangTokenType("..");
  IElementType RAW_STRING = new VlangTokenType("raw_string");
  IElementType RBRACE = new VlangTokenType("}");
  IElementType RBRACK = new VlangTokenType("]");
  IElementType RBRACK_EXP = new VlangTokenType("]!");
  IElementType REMAINDER = new VlangTokenType("%");
  IElementType REMAINDER_ASSIGN = new VlangTokenType("%=");
  IElementType RETURN = new VlangTokenType("return");
  IElementType RLOCK = new VlangTokenType("rlock");
  IElementType RPAREN = new VlangTokenType(")");
  IElementType SELECT = new VlangTokenType("select");
  IElementType SEMICOLON = new VlangTokenType(";");
  IElementType SEMICOLON_SYNTHETIC = new VlangTokenType("<NL>");
  IElementType SEND_CHANNEL = new VlangTokenType("<-");
  IElementType SHARED = new VlangTokenType("shared");
  IElementType SHIFT_LEFT = new VlangTokenType("<<");
  IElementType SHIFT_LEFT_ASSIGN = new VlangTokenType("<<=");
  IElementType SHIFT_RIGHT = new VlangTokenType(">>");
  IElementType SHIFT_RIGHT_ASSIGN = new VlangTokenType(">>=");
  IElementType SINGLE_QUOTE = new VlangTokenType("'");
  IElementType SQL = new VlangTokenType("sql");
  IElementType SQL_LINE = new VlangTokenType("SQL_LINE");
  IElementType STRING = new VlangTokenType("string");
  IElementType STRUCT = new VlangTokenType("struct");
  IElementType SWITCH = new VlangTokenType("switch");
  IElementType TILDA = new VlangTokenType("~");
  IElementType TRIPLE_DOT = new VlangTokenType("...");
  IElementType TRUE = new VlangTokenType("true");
  IElementType TYPE_ = new VlangTokenType("type");
  IElementType UNION = new VlangTokenType("union");
  IElementType UNSAFE = new VlangTokenType("unsafe");
  IElementType VAR = new VlangTokenType("var");
  IElementType VAR_ASSIGN = new VlangTokenType(":=");
  IElementType VOLATILE = new VlangTokenType("volatile");

  class Factory {
    public static PsiElement createElement(ASTNode node) {
      IElementType type = node.getElementType();
      if (type == ADD_EXPR) {
        return new VlangAddExprImpl(node);
      }
      else if (type == AND_EXPR) {
        return new VlangAndExprImpl(node);
      }
      else if (type == ANONYMOUS_FIELD_DEFINITION) {
        return new VlangAnonymousFieldDefinitionImpl(node);
      }
      else if (type == ANONYMOUS_INTERFACE_DEFINITION) {
        return new VlangAnonymousInterfaceDefinitionImpl(node);
      }
      else if (type == ARGUMENT_LIST) {
        return new VlangArgumentListImpl(node);
      }
      else if (type == ARRAY_CREATION) {
        return new VlangArrayCreationImpl(node);
      }
      else if (type == ARRAY_CREATION_LIST) {
        return new VlangArrayCreationListImpl(node);
      }
      else if (type == ARRAY_OR_SLICE_TYPE) {
        return new VlangArrayOrSliceTypeImpl(node);
      }
      else if (type == ASM_BLOCK) {
        return new VlangAsmBlockImpl(node);
      }
      else if (type == ASM_BLOCK_STATEMENT) {
        return new VlangAsmBlockStatementImpl(node);
      }
      else if (type == ASSERT_STATEMENT) {
        return new VlangAssertStatementImpl(node);
      }
      else if (type == ASSIGNMENT_STATEMENT) {
        return new VlangAssignmentStatementImpl(node);
      }
      else if (type == ASSIGN_OP) {
        return new VlangAssignOpImpl(node);
      }
      else if (type == AS_EXPRESSION) {
        return new VlangAsExpressionImpl(node);
      }
      else if (type == ATTRIBUTE) {
        return new VlangAttributeImpl(node);
      }
      else if (type == ATTRIBUTES) {
        return new VlangAttributesImpl(node);
      }
      else if (type == ATTRIBUTE_EXPRESSION) {
        return new VlangAttributeExpressionImpl(node);
      }
      else if (type == BLOCK) {
        return new VlangBlockImpl(node);
      }
      else if (type == BREAK_STATEMENT) {
        return new VlangBreakStatementImpl(node);
      }
      else if (type == CALL_EXPR) {
        return new VlangCallExprImpl(node);
      }
      else if (type == CAPTURE) {
        return new VlangCaptureImpl(node);
      }
      else if (type == CAPTURE_LIST) {
        return new VlangCaptureListImpl(node);
      }
      else if (type == CHANNEL_TYPE) {
        return new VlangChannelTypeImpl(node);
      }
      else if (type == COMPILE_ELSE_STATEMENT) {
        return new VlangCompileElseStatementImpl(node);
      }
      else if (type == COMPILE_TIME_FOR_STATEMENT) {
        return new VlangCompileTimeForStatementImpl(node);
      }
      else if (type == COMPILE_TIME_IF_EXPRESSION) {
        return new VlangCompileTimeIfExpressionImpl(node);
      }
      else if (type == COMPILE_TIME_IF_STATEMENT) {
        return new VlangCompileTimeIfStatementImpl(node);
      }
      else if (type == CONDITIONAL_EXPR) {
        return new VlangConditionalExprImpl(node);
      }
      else if (type == CONSTEXPR_IDENTIFIER_EXPRESSION) {
        return new VlangConstexprIdentifierExpressionImpl(node);
      }
      else if (type == CONST_DECLARATION) {
        return new VlangConstDeclarationImpl(node);
      }
      else if (type == CONST_DEFINITION) {
        return new VlangConstDefinitionImpl(node);
      }
      else if (type == CONST_SPEC) {
        return new VlangConstSpecImpl(node);
      }
      else if (type == CONTINUE_STATEMENT) {
        return new VlangContinueStatementImpl(node);
      }
      else if (type == C_FLAG_STATEMENT) {
        return new VlangCFlagStatementImpl(node);
      }
      else if (type == C_INCLUDE_STATEMENT) {
        return new VlangCIncludeStatementImpl(node);
      }
      else if (type == DEFAULT_FIELD_VALUE) {
        return new VlangDefaultFieldValueImpl(node);
      }
      else if (type == DEFER_STATEMENT) {
        return new VlangDeferStatementImpl(node);
      }
      else if (type == DOT_EXPRESSION) {
        return new VlangDotExpressionImpl(node);
      }
      else if (type == ELSE_STATEMENT) {
        return new VlangElseStatementImpl(node);
      }
      else if (type == ENUM_DECLARATION) {
        return new VlangEnumDeclarationImpl(node);
      }
      else if (type == ENUM_FETCH) {
        return new VlangEnumFetchImpl(node);
      }
      else if (type == ENUM_FIELDS) {
        return new VlangEnumFieldsImpl(node);
      }
      else if (type == ENUM_FIELD_DECLARATION) {
        return new VlangEnumFieldDeclarationImpl(node);
      }
      else if (type == ERROR_PROPAGATION_EXPRESSION) {
        return new VlangErrorPropagationExpressionImpl(node);
      }
      else if (type == FIELD_DECLARATION) {
        return new VlangFieldDeclarationImpl(node);
      }
      else if (type == FIELD_INITIALIZATION) {
        return new VlangFieldInitializationImpl(node);
      }
      else if (type == FIELD_INITIALIZATION_KEY) {
        return new VlangFieldInitializationKeyImpl(node);
      }
      else if (type == FIELD_INITIALIZATION_KEY_VALUE_LIST) {
        return new VlangFieldInitializationKeyValueListImpl(node);
      }
      else if (type == FIELD_INITIALIZATION_VALUE_LIST) {
        return new VlangFieldInitializationValueListImpl(node);
      }
      else if (type == FIELD_LOOKUP) {
        return new VlangFieldLookupImpl(node);
      }
      else if (type == FIELD_NAME) {
        return new VlangFieldNameImpl(node);
      }
      else if (type == FORCE_NO_ERROR_PROPAGATION_EXPRESSION) {
        return new VlangForceNoErrorPropagationExpressionImpl(node);
      }
      else if (type == FOR_CLAUSE) {
        return new VlangForClauseImpl(node);
      }
      else if (type == FOR_STATEMENT) {
        return new VlangForStatementImpl(node);
      }
      else if (type == FUNCTION_DECLARATION) {
        return new VlangFunctionDeclarationImpl(node);
      }
      else if (type == FUNCTION_LIT) {
        return new VlangFunctionLitImpl(node);
      }
      else if (type == FUNCTION_TYPE) {
        return new VlangFunctionTypeImpl(node);
      }
      else if (type == GENERIC_DECLARATION) {
        return new VlangGenericDeclarationImpl(node);
      }
      else if (type == GENERIC_DECLARATION_LIST) {
        return new VlangGenericDeclarationListImpl(node);
      }
      else if (type == GENERIC_NAME) {
        return new VlangGenericNameImpl(node);
      }
      else if (type == GLOBAL_VARIABLE_DECLARATION) {
        return new VlangGlobalVariableDeclarationImpl(node);
      }
      else if (type == GOTO_STATEMENT) {
        return new VlangGotoStatementImpl(node);
      }
      else if (type == GO_EXPRESSION) {
        return new VlangGoExpressionImpl(node);
      }
      else if (type == GO_STATEMENT) {
        return new VlangGoStatementImpl(node);
      }
      else if (type == IF_ATTRIBUTE) {
        return new VlangIfAttributeImpl(node);
      }
      else if (type == IF_EXPRESSION) {
        return new VlangIfExpressionImpl(node);
      }
      else if (type == IF_STATEMENT) {
        return new VlangIfStatementImpl(node);
      }
      else if (type == IMPORT_ALIAS) {
        return new VlangImportAliasImpl(node);
      }
      else if (type == IMPORT_DECLARATION) {
        return new VlangImportDeclarationImpl(node);
      }
      else if (type == IMPORT_LIST) {
        return new VlangImportListImpl(node);
      }
      else if (type == IMPORT_SPEC) {
        return new VlangImportSpecImpl(node);
      }
      else if (type == INC_DEC_EXPRESSION) {
        return new VlangIncDecExpressionImpl(node);
      }
      else if (type == INDEX_OR_SLICE_EXPR) {
        return new VlangIndexOrSliceExprImpl(node);
      }
      else if (type == INTERFACE_DECLARATION) {
        return new VlangInterfaceDeclarationImpl(node);
      }
      else if (type == INTERFACE_FIELD_DECLARATION) {
        return new VlangInterfaceFieldDeclarationImpl(node);
      }
      else if (type == INTERFACE_METHOD_DECLARATION) {
        return new VlangInterfaceMethodDeclarationImpl(node);
      }
      else if (type == INTERFACE_TYPE) {
        return new VlangInterfaceTypeImpl(node);
      }
      else if (type == IN_EXPRESSION) {
        return new VlangInExpressionImpl(node);
      }
      else if (type == IS_EXPRESSION) {
        return new VlangIsExpressionImpl(node);
      }
      else if (type == KEY_VALUE) {
        return new VlangKeyValueImpl(node);
      }
      else if (type == KEY_VALUES) {
        return new VlangKeyValuesImpl(node);
      }
      else if (type == LABEL) {
        return new VlangLabelImpl(node);
      }
      else if (type == LABELED_STATEMENT) {
        return new VlangLabeledStatementImpl(node);
      }
      else if (type == LABEL_REF) {
        return new VlangLabelRefImpl(node);
      }
      else if (type == LANGUAGE_INJECTION_STATEMENT) {
        return new VlangLanguageInjectionStatementImpl(node);
      }
      else if (type == LEFT_HAND_EXPR_LIST) {
        return new VlangLeftHandExprListImpl(node);
      }
      else if (type == LITERAL) {
        return new VlangLiteralImpl(node);
      }
      else if (type == LOCK_EXPRESSION) {
        return new VlangLockExpressionImpl(node);
      }
      else if (type == LOCK_STATEMENT) {
        return new VlangLockStatementImpl(node);
      }
      else if (type == MAP_INIT_EXPR) {
        return new VlangMapInitExprImpl(node);
      }
      else if (type == MAP_TYPE) {
        return new VlangMapTypeImpl(node);
      }
      else if (type == MATCH_ARM) {
        return new VlangMatchArmImpl(node);
      }
      else if (type == MATCH_ARMS) {
        return new VlangMatchArmsImpl(node);
      }
      else if (type == MATCH_ELSE_ARM_CLAUSE) {
        return new VlangMatchElseArmClauseImpl(node);
      }
      else if (type == MATCH_EXPRESSION) {
        return new VlangMatchExpressionImpl(node);
      }
      else if (type == MEMBER_MODIFIER) {
        return new VlangMemberModifierImpl(node);
      }
      else if (type == MEMBER_MODIFIERS) {
        return new VlangMemberModifiersImpl(node);
      }
      else if (type == METHOD_CALL) {
        return new VlangMethodCallImpl(node);
      }
      else if (type == METHOD_DECLARATION) {
        return new VlangMethodDeclarationImpl(node);
      }
      else if (type == METHOD_NAME) {
        return new VlangMethodNameImpl(node);
      }
      else if (type == MODULE_CLAUSE) {
        return new VlangModuleClauseImpl(node);
      }
      else if (type == MUL_EXPR) {
        return new VlangMulExprImpl(node);
      }
      else if (type == MUT_EXPRESSION) {
        return new VlangMutExpressionImpl(node);
      }
      else if (type == NOT_IN_EXPRESSION) {
        return new VlangNotInExpressionImpl(node);
      }
      else if (type == NOT_IS_EXPRESSION) {
        return new VlangNotIsExpressionImpl(node);
      }
      else if (type == NOT_NULLABLE_TYPE) {
        return new VlangNotNullableTypeImpl(node);
      }
      else if (type == NULLABLE_TYPE) {
        return new VlangNullableTypeImpl(node);
      }
      else if (type == OR_BLOCK_EXPR) {
        return new VlangOrBlockExprImpl(node);
      }
      else if (type == OR_EXPR) {
        return new VlangOrExprImpl(node);
      }
      else if (type == PARAMETERS) {
        return new VlangParametersImpl(node);
      }
      else if (type == PARAMETER_DECLARATION) {
        return new VlangParameterDeclarationImpl(node);
      }
      else if (type == PARAM_DEFINITION) {
        return new VlangParamDefinitionImpl(node);
      }
      else if (type == PARENTHESES_EXPR) {
        return new VlangParenthesesExprImpl(node);
      }
      else if (type == PLAIN_ATTRIBUTE) {
        return new VlangPlainAttributeImpl(node);
      }
      else if (type == POINTER_TYPE) {
        return new VlangPointerTypeImpl(node);
      }
      else if (type == RANGE_CLAUSE) {
        return new VlangRangeClauseImpl(node);
      }
      else if (type == RANGE_EXPR) {
        return new VlangRangeExprImpl(node);
      }
      else if (type == RECEIVER) {
        return new VlangReceiverImpl(node);
      }
      else if (type == REFERENCE_EXPRESSION) {
        return new VlangReferenceExpressionImpl(node);
      }
      else if (type == RESULT) {
        return new VlangResultImpl(node);
      }
      else if (type == RETURN_STATEMENT) {
        return new VlangReturnStatementImpl(node);
      }
      else if (type == SELECTIVE_IMPORT_LIST) {
        return new VlangSelectiveImportListImpl(node);
      }
      else if (type == SEND_EXPR) {
        return new VlangSendExprImpl(node);
      }
      else if (type == SEND_STATEMENT) {
        return new VlangSendStatementImpl(node);
      }
      else if (type == SHARED_EXPRESSION) {
        return new VlangSharedExpressionImpl(node);
      }
      else if (type == SIGNATURE) {
        return new VlangSignatureImpl(node);
      }
      else if (type == SIMPLE_STATEMENT) {
        return new VlangSimpleStatementImpl(node);
      }
      else if (type == SQL_BLOCK) {
        return new VlangSqlBlockImpl(node);
      }
      else if (type == SQL_EXPRESSION) {
        return new VlangSqlExpressionImpl(node);
      }
      else if (type == SQL_STATEMENT) {
        return new VlangSqlStatementImpl(node);
      }
      else if (type == STATEMENT) {
        return new VlangStatementImpl(node);
      }
      else if (type == STRING_LITERAL) {
        return new VlangStringLiteralImpl(node);
      }
      else if (type == STRUCT_DECLARATION) {
        return new VlangStructDeclarationImpl(node);
      }
      else if (type == STRUCT_TYPE) {
        return new VlangStructTypeImpl(node);
      }
      else if (type == SYMBOL_VISIBILITY) {
        return new VlangSymbolVisibilityImpl(node);
      }
      else if (type == TAG) {
        return new VlangTagImpl(node);
      }
      else if (type == TYPE_ALIAS_DECLARATION) {
        return new VlangTypeAliasDeclarationImpl(node);
      }
      else if (type == TYPE_DECL) {
        return new VlangTypeDeclImpl(node);
      }
      else if (type == TYPE_INIT_EXPR) {
        return new VlangTypeInitExprImpl(node);
      }
      else if (type == TYPE_LIST_NO_PIN) {
        return new VlangTypeListNoPinImpl(node);
      }
      else if (type == TYPE_REFERENCE_EXPRESSION) {
        return new VlangTypeReferenceExpressionImpl(node);
      }
      else if (type == TYPE_UNION_LIST) {
        return new VlangTypeUnionListImpl(node);
      }
      else if (type == UNARY_EXPR) {
        return new VlangUnaryExprImpl(node);
      }
      else if (type == UNION_DECLARATION) {
        return new VlangUnionDeclarationImpl(node);
      }
      else if (type == UNPACKING_EXPRESSION) {
        return new VlangUnpackingExpressionImpl(node);
      }
      else if (type == UNSAFE_EXPRESSION) {
        return new VlangUnsafeExpressionImpl(node);
      }
      else if (type == UNSAFE_STATEMENT) {
        return new VlangUnsafeStatementImpl(node);
      }
      else if (type == VAR_DECLARATION) {
        return new VlangVarDeclarationImpl(node);
      }
      else if (type == VAR_DEFINITION) {
        return new VlangVarDefinitionImpl(node);
      }
      else if (type == VAR_MODIFIERS) {
        return new VlangVarModifiersImpl(node);
      }
      throw new AssertionError("Unknown element type: " + type);
    }
  }
}
